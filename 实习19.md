# 实习19

## etcd提供的API

+ Put(key, value)/Delete(key)
+ Get(key)/Get(keyFrom, keyEnd)
+ Watch(key/keyPrefix)
+ Transactions(if/then/else ops).Commit()
+ Leases: Grant/Revoke/KeepAlive

## etcd学习计划

+ etcdserver交互层
+ raft层
+ 网络层
  + 分布式事务的实现
+ 存储层
  + 日志存储-wal、
  + 数据存储-内存索引、mvcc、boltdb
+ 二方库
  + 分布式锁
  + watch和租约的实现

TODO:

+ *状态机逻辑*和*raft算法*解耦

### 1. etcdserver交互层

#### 1.1 raft.go交互逻辑

+ etcdserver包下的raft.go文件包含了处理和raft模块交互的逻辑
  + 提供定时器tick给raft模块
  + 处理raft模块的输出消息结果
+ 不负责处理到来的网络消息，网络消息由网络层直接传递给raft层

#### 1.2 server.go服务器主逻辑


#### 1.3 数据结构

1. `apply`结构体
    + log entries
    + snapshot
    + notifyc - 是否同步完成
2. `raftNode`结构体
    + 内嵌`raftNodeConfig`结构体
    + msgSnapC: 输出/接受snapshot？
    + applyC: 输出`apply`的channel
    + readStateC: 输出readState的channel
    + 定时器+超时检测器
    + stopped、done channel
3. `raftNodeConfig`结构体
    + 内嵌`raft.Node`结构体
    + 内存存储 - raftStorage
    + 存储层交互对象 - `storage`实现Storage接口
    + 网络层交互对象 - `transport`实现rafthttp.Transporter接口
    + 心跳间隔配置（100ms）

#### 1.4 关键算法

1. `start`函数
  1. 定时器触发tick消息
  2. 接受raft模块输出：`ready`结构体(见raft模块)封装
    + 读请求结果放入readStateC
    + 初始化notifyc长度为1，用ready中数据封装apply
    + 更新committed索引
    + 放入applyc中，存储层进行下一步持久化
    + 如果是leader并行地通过网络层向其它节点发送备份数据 -> 需要看论文10.2.1部分
    + 如果有，持久化snapshot
    + 如果有，持久化hardstate和entries
    + 如果有snapshot
      + fsync同步，确保snapshot持久化？
      + 通过notifyc告知snapshot持久化完成
      + 应用snapshot到内存log entries
      + 释放snapshot对应索引前的log文件的锁，同时删除文件
    + 内存中append log entries
    + 如果非leader
      + 非阻塞处理消息(判断是否heartbeat超时e)
      + 通知notifyc，解锁`applyAll`开始应用snapshot操作(说明snapshot已经持久化，可以应用到存储层)
      + 若存在entryConfChange消息？(作用是什么)
      + 再次通知notifyc，阻塞自己直到server.go中`applyAll`调用`applyWait.Trigger`
      + config-change完成，发送剩余msgs
    + 如果为leader则snapshot已经持久化，直接通知notifyc，触发apply
    + 启动raft模块下一次处理

### 2. raft层



#### 数据结构

1. `ready`算法输出结构体
    + Softstate内嵌易失性节点状态，若无更新则为nil
    + Hardstate内嵌需要持久化的状态，若无更新则为空
    + ReadStates读请求得到的结果
    + Entries
